package dreamwisp.ui {	import dreamwisp.entity.components.Body;	import dreamwisp.entity.components.View;	import dreamwisp.entity.hosts.Entity;	import dreamwisp.entity.hosts.IPlayerControllable;	import dreamwisp.input.InputState;	import dreamwisp.input.KeyMap;	import flash.display.MovieClip;	import flash.text.TextField;	import flash.ui.Keyboard;		/**	 * DialogueBox is a conversation explorer.	 * Its appearance varies, through an interchangable MovieClip. 	 * It controls the display and navigation of conversations, 	 * @author Brandon	 */	public class DialogueBox extends Entity implements IPlayerControllable	{		private static const KEY_SPEAKER:String = "speaker";		private static const KEY_DIALOGUE:String = "dialogue";				private static const STATE_HIDDEN:uint = 0;		private static const STATE_READING:uint = 1;		private static const STATE_FINISHED:uint = 2;		private var state:uint = STATE_HIDDEN;				private var conversation:Array;		private var convoProgress:uint = 0;				private var displayedSpeaker:String;		private var loadedDialogue:String;		private var displayedDialogue:String;				private var keyMap:KeyMap;				public function DialogueBox(movieClip:MovieClip) 		{			if (movieClip.getChildByName(KEY_SPEAKER) == null)				throw new Error("The MovieClip for DialogueBox is missing a necessary speaker textField!");			if (movieClip.getChildByName(KEY_DIALOGUE) == null)				throw new Error("The MovieClip for DialogueBox is missing a necessary dialogue textField!");						body = new Body(this, movieClip.width, movieClip.height);						view = new View(this, movieClip);						keyMap = new KeyMap();			keyMap.bind(Keyboard.Z, readPrev);			keyMap.bind(Keyboard.X, readNext);		}				private function readPrev():void 		{			if (convoProgress <= 0)				return;			read(convoProgress - 1);				}				private function readNext():void 		{			// still reading? this will transfer remainder & immediately finish			if (state == STATE_READING)			{				displayedDialogue += loadedDialogue;				loadedDialogue = "";				state = STATE_FINISHED;				return;			}			// reached conversation end, close the box			if (convoProgress == conversation.length - 1)			{				hide();				return;			}			read(convoProgress + 1);		}				/**		 * Opens a conversation that this DialogueBox can explore internally. 		 * @param	conversation a linear array preverified to contain Speaker and Dialogue text.		 */				public function load(conversation:Array):void 		{			if (conversation == null || conversation.length == 0)				throw new Error("Conversation is empty!");						this.conversation = conversation;			read(0)		}				public function read(convoProgress:uint):void 		{			state = STATE_READING;			displayedSpeaker = conversation[convoProgress].speaker;			loadedDialogue = conversation[convoProgress].dialogue;			displayedDialogue = "";			this.convoProgress = convoProgress;		}				override public function update():void 		{			if (state == STATE_HIDDEN) return;			super.update();			if (state == STATE_READING)			{				// analyze amount of chars to be cut every tick				var length:int = 1;				// detects HTML tags and pastes entirety in one tick				if (loadedDialogue.substr(0, 1) == "<")				{					length = loadedDialogue.indexOf(">");				}				// cut and paste to display				displayedDialogue += loadedDialogue.substr(0, length);				loadedDialogue = loadedDialogue.substr(length);				// finished copying everything				if (loadedDialogue.length == 0)					state = STATE_FINISHED;			}		}				override public function render(interpolation:Number):void 		{			if (state == STATE_HIDDEN) return;			super.render(interpolation);			accessField(KEY_SPEAKER).htmlText = displayedSpeaker;			accessField(KEY_DIALOGUE).htmlText = displayedDialogue;		}				private function show():void 		{			view.movieClip.visible = true;		}				private function hide():void 		{			state = STATE_HIDDEN;			view.movieClip.visible = false;		}				private function accessField(field:String):TextField		{			return TextField(view.movieClip.getChildByName(field));		}		public function handleInput(inputState:InputState):void 		{			keyMap.readInput(inputState);		}			}}