package dreamwisp.swift.ds {	import flash.utils.Dictionary;		/**	 * PriorityQueue that presents items with lowest priority first.	 * It is implemented as a complete binary tree/heap.	 * @author Brandon	 */	public class PriorityQueue 	{		private var count:int;		private var heap:Array;				public function PriorityQueue() 		{			init();		}				private function init():void 		{			heap = new Array(null); // first element in the array isn't included			count = 0;		}				/**		 * Finds and returns the lowest priority item.		 */		public function front():* 		{			return heap[1];		}				/**		 * Adds an prioritized item to the queue.		 * @param	item an object with a priority field		 * @param	priority		 */		public function enqueue(item:*, priority:int):void 		{			count = heap.push(item) - 1;			item.priority = priority;			walkUp(count);		}				private function walkUp(index:int):void		{			var parentIndex:int = index / 2;			var parent:* = heap[parentIndex];			var p:int = heap[index].priority;						// keep swapping up if the parent has a higher priority			while (parentIndex > 0)			{				if (parent.priority > p)				{					swap(parentIndex, index);					index = parentIndex;					parentIndex = parentIndex / 2;					parent = heap[parentIndex];				}				else break;			}		}				/**		 * Removes and returns the lowest priority item.		 * @return		 */		public function dequeue():* 		{			if (count >= 1)			{				var item:* = heap[1];								// swap first node with last node				swap(1, count);				walkDown(1);								count--;				return heap.pop();			}			return null;		}				private function walkDown(index:int):void 		{			var childIndex:int = index << 1;			var p:int = heap[index].priority;			while (childIndex < count)			{				if (childIndex < count - 1) // not the last child, so there's two children				{					// choose the lowest priority child					if (heap[childIndex].priority > heap[childIndex + 1].priority)						childIndex++;				}				// swap with it				if (heap[childIndex].priority < p)				{					swap(childIndex, index);					index = childIndex;					childIndex <<= 1;				}				else return;			}		}				private function swap(index1:int, index2:uint):void 		{			var temp:* = heap[index1];			heap[index1] = heap[index2];			heap[index2] = temp;		}				public function clear():void 		{			init();		}				/// Current number of items in the queue		public function size():int		{			return count;		}				public function isEmpty():Boolean		{			return count == 0;		}				public function toString():Array		{			return heap;		}			}}