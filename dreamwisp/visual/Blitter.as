package dreamwisp.visual {	import flash.display.BitmapData;	import flash.geom.ColorTransform;	import flash.geom.Point;	import flash.geom.Rectangle;		/**	 * Blitter is a component that handles bitmap graphics operations.	 * With blit methods, it acts as a mediator for drawing from a SpriteSheet to a canvas,	 * whether that canvas belongs to a GameScreen or an individual Entity	 * (that would then want to use Blitter to draw its own pixels back to GameScreen)	 * @author Brandon	 */		public class Blitter 	{		private var source:BitmapData;		private var canvas:BitmapData;		private var spriteSheet:SpriteSheet;				/**		 * 		 * @param	source The spritesheet image this Blitter will use to draw.		 * @param	canvas The target BitmapData this Blitter will draw to.		 * @param	sheetData A JSON file with information for blitting from the source image.		 */		public function Blitter(canvas:BitmapData, spriteSheet:SpriteSheet)		{			this.canvas = canvas;			this.spriteSheet = spriteSheet;			this.source = spriteSheet.getImage();		}				/**		 * Gives a reference to the current sprite sheet for independently 		 * handling bitmap graphics before blitting it through to the target canvas. 		 * @return		 */		public function getSpriteSheet():SpriteSheet		{			return spriteSheet;		}				/**		 * Draws to the canvas using the image defined in the sprite sheet.		 * @param	name The name of the group of related sprites (e.g. "Tiles")		 * @param	item The index of the blittable item in that group (e.g. for "Tile", #5) 		 * @param	frame The animation frame the item should move to. 		 *   The default value is -1, which means the item does not have more frames.		 */		public function blit(name:String, item:uint, x:Number = 0, y:Number = 0,			frame:uint = 0, newTarget:BitmapData = null):void 		{			// this function seems like it would belong more in an Entity			// because simple, unmodified bitmapData is something that should 			// belong with the Entity state. It would manipulate and handle its 			// own animation until it blitsTo() the GameScreen canvas.			const data:Object = spriteSheet.access(name, item);						var dimens:Object;			if (!data.frames)				dimens = data.frame;			else				dimens = data.frames[frame];						//TODO: Get the sourceSize w and h to guarantee a full paste?			//		or a spriteSourceSize w and h?			const rect:Rectangle = new Rectangle( dimens.x, dimens.y, dimens.w, dimens.h /*32*/ );			if (newTarget)				newTarget.copyPixels( source, rect, new Point(x, y)/*, null, null, true*/ );			else				canvas.copyPixels( source, rect, new Point(x, y), null, null, true );						//var color:ColorTransform = new ColorTransform();			//canvas.colorTransform( rect, color );		}				/**		 * Draws to the canvas using another BitampData instead of the current sprite sheet stored. 		 * @param	otherSource		 * @param	rect		 * @param	x		 * @param	y		 */		public function blitWith(otherSource:BitmapData, rect:Rectangle, x:Number = 0, y:Number = 0			):void 		{			canvas.copyPixels( otherSource, rect, new Point(x, y), null, null, true );		}				public function erase(rect:Rectangle, x:Number = 0, y:Number = 0):void 		{					}			}}